module imper-repeat where

open import lib

--
-- variable identifiers
--
𝕀𝕕𝕖𝕟 : Set
𝕀𝕕𝕖𝕟 = string

_=𝕀𝕕𝕖𝕟_ : 𝕀𝕕𝕖𝕟 → 𝕀𝕕𝕖𝕟 → 𝔹
_=𝕀𝕕𝕖𝕟_ = _=string_

--
-- values (just natural numbers here)
--
𝕍𝕒𝕝𝕦 : Set
𝕍𝕒𝕝𝕦 = ℕ

--
-- value and variable expressions
--
data 𝔼𝕩𝕡𝕟 : Set where
  ⇓_ : 𝕍𝕒𝕝𝕦 → 𝔼𝕩𝕡𝕟
  ⇑_ : 𝕀𝕕𝕖𝕟 → 𝔼𝕩𝕡𝕟
  _+𝕖_ : 𝔼𝕩𝕡𝕟 → 𝔼𝕩𝕡𝕟 → 𝔼𝕩𝕡𝕟
  _-𝕖_ : 𝔼𝕩𝕡𝕟 → 𝔼𝕩𝕡𝕟 → 𝔼𝕩𝕡𝕟
  _*𝕖_ : 𝕍𝕒𝕝𝕦 → 𝔼𝕩𝕡𝕟 → 𝔼𝕩𝕡𝕟

--
-- conditions on values and variables
--
data ℂ𝕠𝕟𝕕 : Set where
  ⇓true : ℂ𝕠𝕟𝕕
  ⇓false : ℂ𝕠𝕟𝕕
  _∧𝕔_ : ℂ𝕠𝕟𝕕 → ℂ𝕠𝕟𝕕 → ℂ𝕠𝕟𝕕
  _∨𝕔_ : ℂ𝕠𝕟𝕕 → ℂ𝕠𝕟𝕕 → ℂ𝕠𝕟𝕕
  ¬𝕔_ : ℂ𝕠𝕟𝕕 → ℂ𝕠𝕟𝕕
  _<𝕔_ : 𝔼𝕩𝕡𝕟 → 𝔼𝕩𝕡𝕟 → ℂ𝕠𝕟𝕕
  _=𝕔_ : 𝔼𝕩𝕡𝕟 → 𝔼𝕩𝕡𝕟 → ℂ𝕠𝕟𝕕

--
-- stack frames containing variable bindings
--
𝔽𝕣𝕞𝕖 : Set
𝔽𝕣𝕞𝕖 = 𝕃 (𝕀𝕕𝕖𝕟 × 𝕍𝕒𝕝𝕦)

[-↦0] : 𝔽𝕣𝕞𝕖
[-↦0] = []

_↦_ : 𝕀𝕕𝕖𝕟 → 𝕍𝕒𝕝𝕦 → 𝕀𝕕𝕖𝕟 × 𝕍𝕒𝕝𝕦
𝒙 ↦ 𝓋 = (𝒙 , 𝓋)

--
-- program statements that transform a frame
--
data 𝕊𝕥𝕞𝕥 : Set where
  skip : 𝕊𝕥𝕞𝕥
  _∷=_ : 𝕀𝕕𝕖𝕟 → 𝔼𝕩𝕡𝕟 → 𝕊𝕥𝕞𝕥
  _↩_ : 𝕊𝕥𝕞𝕥 → 𝕊𝕥𝕞𝕥 → 𝕊𝕥𝕞𝕥
  if_then_else_end : ℂ𝕠𝕟𝕕 → 𝕊𝕥𝕞𝕥 → 𝕊𝕥𝕞𝕥 → 𝕊𝕥𝕞𝕥
  by_repeat_end : 𝕀𝕕𝕖𝕟 → 𝕊𝕥𝕞𝕥 → 𝕊𝕥𝕞𝕥
  returns : 𝔼𝕩𝕡𝕟 → 𝕊𝕥𝕞𝕥

infix 11 ⇑_ ⇓_
infixr 10 _*𝕖_
infixl 9 _+𝕖_ _-𝕖_
infix 8 _=𝕔_ _<𝕔_
infix 7 ¬𝕔_
infixl 6 _∨𝕔_
infixl 5 _∧𝕔_
infix 4 _∷=_
infix 3 returns
infixl 2 _↩_

--
-- functional SEMANTICS of frames
--

lookup : 𝕀𝕕𝕖𝕟 → 𝔽𝕣𝕞𝕖 → 𝕍𝕒𝕝𝕦
lookup 𝒙 [] = 0
lookup 𝒙 ((𝒚 , 𝓌) :: ℱ) = if (𝒙 =𝕀𝕕𝕖𝕟 𝒚) then 𝓌 else (lookup 𝒙 ℱ)

_∣_↦_ : 𝔽𝕣𝕞𝕖 → 𝕀𝕕𝕖𝕟 → 𝕍𝕒𝕝𝕦 → 𝔽𝕣𝕞𝕖
[] ∣ 𝒙 ↦ 𝓋 = [ 𝒙 ↦ 𝓋 ]
((𝒚 , 𝓌) :: ℱ) ∣ 𝒙 ↦ 𝓋 = if (𝒙 =𝕀𝕕𝕖𝕟 𝒚)
                              then (𝒚 ↦ 𝓋) :: ℱ
                              else (𝒚 ↦ 𝓌) :: (ℱ ∣ 𝒙 ↦ 𝓋)

--
-- functional SEMANTICS of expressions
--
⟦_⟧𝕖_ : 𝔼𝕩𝕡𝕟 → 𝔽𝕣𝕞𝕖 → 𝕍𝕒𝕝𝕦
⟦ (⇓ 𝓋) ⟧𝕖 _ = 𝓋
⟦ (⇑ 𝒙) ⟧𝕖 ℱ = lookup 𝒙 ℱ
⟦ ℯ₁ +𝕖 ℯ₂ ⟧𝕖 ℱ = (⟦ ℯ₁ ⟧𝕖 ℱ) + (⟦ ℯ₂ ⟧𝕖 ℱ)
⟦ ℯ₁ -𝕖 ℯ₂ ⟧𝕖 ℱ = (⟦ ℯ₁ ⟧𝕖 ℱ) ∸ (⟦ ℯ₂ ⟧𝕖 ℱ)
⟦ 𝓋₁ *𝕖 ℯ₂ ⟧𝕖 ℱ = 𝓋₁ * (⟦ ℯ₂ ⟧𝕖 ℱ)

--
-- functional SEMANTICS of conditions
--
⟦_⟧𝕔_ : ℂ𝕠𝕟𝕕 → 𝔽𝕣𝕞𝕖 → 𝔹
⟦ ⇓true ⟧𝕔 _ = tt
⟦ ⇓false ⟧𝕔 _ = ff
⟦ 𝒸₁ ∧𝕔 𝒸₂ ⟧𝕔 ℱ = (⟦ 𝒸₁ ⟧𝕔 ℱ) && (⟦ 𝒸₂ ⟧𝕔 ℱ)
⟦ 𝒸₁ ∨𝕔 𝒸₂ ⟧𝕔 ℱ = (⟦ 𝒸₁ ⟧𝕔 ℱ) || (⟦ 𝒸₂ ⟧𝕔 ℱ)
⟦ ¬𝕔 𝒸 ⟧𝕔 ℱ = ~ (⟦ 𝒸 ⟧𝕔 ℱ)
⟦ ℯ₁ <𝕔 ℯ₂ ⟧𝕔 ℱ = (⟦ ℯ₁ ⟧𝕖 ℱ) < (⟦ ℯ₂ ⟧𝕖 ℱ)
⟦ ℯ₁ =𝕔 ℯ₂ ⟧𝕔 ℱ = (⟦ ℯ₁ ⟧𝕖 ℱ) =ℕ (⟦ ℯ₂ ⟧𝕖 ℱ)

repeatedly : 𝕀𝕕𝕖𝕟 → ℕ → 𝕊𝕥𝕞𝕥 → 𝔽𝕣𝕞𝕖 → 𝔽𝕣𝕞𝕖
⟦_⟧𝕤_ : 𝕊𝕥𝕞𝕥 → 𝔽𝕣𝕞𝕖 → 𝔽𝕣𝕞𝕖
repeatedly 𝒙 0 𝓈 ℱ = ℱ
repeatedly 𝒙 (suc n) 𝓈 ℱ = repeatedly 𝒙 n 𝓈 ((⟦ 𝓈 ⟧𝕤 ℱ) ∣ 𝒙 ↦ n )
⟦ skip ⟧𝕤 ℱ = ℱ
⟦ 𝒙 ∷= ℯ ⟧𝕤 ℱ = (ℱ ∣ 𝒙 ↦ (⟦ ℯ ⟧𝕖 ℱ))
⟦ 𝓈₁ ↩ 𝓈₂ ⟧𝕤 ℱ = (⟦ 𝓈₂ ⟧𝕤 (⟦ 𝓈₁ ⟧𝕤 ℱ))
⟦ if 𝒸 then 𝓈₁ else 𝓈₂ end ⟧𝕤 ℱ = if (⟦ 𝒸 ⟧𝕔 ℱ) then (⟦ 𝓈₁ ⟧𝕤 ℱ) else (⟦ 𝓈₂ ⟧𝕤 ℱ)
⟦ by 𝒙 repeat 𝓈 end ⟧𝕤 ℱ = repeatedly 𝒙 (⟦ ⇑ 𝒙 ⟧𝕖 ℱ) 𝓈 ℱ
⟦ returns ℯ ⟧𝕤 ℱ = ℱ ∣ "retval" ↦ (⟦ ℯ ⟧𝕖 ℱ)

arg1 : 𝕀𝕕𝕖𝕟
arg1 = "arg1"

arg2 : 𝕀𝕕𝕖𝕟
arg2 = "arg2"

retval : 𝕀𝕕𝕖𝕟
retval = "retval"

W : 𝕀𝕕𝕖𝕟
W = "w"

X : 𝕀𝕕𝕖𝕟
X = "x"

Y : 𝕀𝕕𝕖𝕟
Y = "y"

Z : 𝕀𝕕𝕖𝕟
Z = "z"

pgm0 : 𝕊𝕥𝕞𝕥
pgm0 = X ∷= ⇓ 3 ↩
       Y ∷= ⇓ 1 ↩
       Y ∷= 2 *𝕖 ⇑ Y

pgm1 : 𝕊𝕥𝕞𝕥
pgm1 = X ∷= ⇓ 3 ↩
       Y ∷= ⇓ 1 ↩
       by X repeat
         Y ∷= 2 *𝕖 ⇑ Y
       end

Z∷=X*Y = W ∷= ⇑ X ↩
         Z ∷= ⇓ 0 ↩
         by W repeat
           Z ∷= ⇑ Z +𝕖 ⇑ Y
         end


pgm2 = X ∷= ⇓ 3 ↩
       Y ∷= ⇓ 1 ↩
       by X repeat
         Z∷=X*Y ↩
         Y ∷= ⇑ Z
       end


fact-pgm : 𝕊𝕥𝕞𝕥
fact-pgm =
  (X ∷= (⇑ arg1)) ↩
  (Y ∷= (⇓ 1)) ↩
  (by X repeat (
    Z∷=X*Y ↩
    (Y ∷= (⇑ Z)))
  end) ↩
  (returns (⇑ Y))


result1 = ⟦ pgm1 ⟧𝕤 [-↦0]
result2 = ⟦ pgm2 ⟧𝕤 [-↦0]


--
-- SEMANTICS of stack bindings as a relation
--

data _⊢_↦_ : 𝔽𝕣𝕞𝕖 → 𝕀𝕕𝕖𝕟 → 𝕍𝕒𝕝𝕦 → Set where

  var-undef : ∀ {𝒙 : 𝕀𝕕𝕖𝕟}
              ----------------
              → [] ⊢ 𝒙 ↦ 0

  var-match : ∀ {𝒙 : 𝕀𝕕𝕖𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋 : 𝕍𝕒𝕝𝕦}
              ---------------------------
              → ((𝒙 , 𝓋) :: ℱ) ⊢ 𝒙 ↦ 𝓋

  var-mismatch : ∀ {𝒙 𝒚 : 𝕀𝕕𝕖𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋 𝓌 : 𝕍𝕒𝕝𝕦}
                 → (𝒙 =string 𝒚) ≢ ff
                 → ℱ ⊢ 𝒙 ↦ 𝓋
                 -------------------------
                 → ((𝒚 , 𝓌) :: ℱ) ⊢ 𝒙 ↦ 𝓋

--
-- SEMANTICS of expression evaluation as a relation
--

data _⊢_⇓_ : 𝔽𝕣𝕞𝕖 → 𝔼𝕩𝕡𝕟 → 𝕍𝕒𝕝𝕦 → Set where

  𝕖-const : ∀ {𝓋 : 𝕍𝕒𝕝𝕦} {ℱ : 𝔽𝕣𝕞𝕖}
            ----------------
            → ℱ ⊢ (⇓ 𝓋) ⇓ 𝓋

  𝕖-var : ∀ {𝒙 : 𝕀𝕕𝕖𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋 : 𝕍𝕒𝕝𝕦}
          → ℱ ⊢ 𝒙 ↦ 𝓋
          ---------------
          → ℱ ⊢ (⇑ 𝒙) ⇓ 𝓋

  𝕖-sum : ∀ {ℯ₁ ℯ₂ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋₁ 𝓋₂ : 𝕍𝕒𝕝𝕦}
                            → ℱ ⊢ ℯ₁ ⇓ 𝓋₁
                            → ℱ ⊢ ℯ₂ ⇓ 𝓋₂
                            ---------------------------
                            → ℱ ⊢ (ℯ₁ +𝕖 ℯ₂) ⇓ (𝓋₁ + 𝓋₂)

  𝕖-sub : ∀ {ℯ₁ ℯ₂ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋₁ 𝓋₂ : 𝕍𝕒𝕝𝕦}
                            → ℱ ⊢ ℯ₁ ⇓ 𝓋₁
                            → ℱ ⊢ ℯ₂ ⇓ 𝓋₂
                            ---------------------------
                            → ℱ ⊢ (ℯ₁ -𝕖 ℯ₂) ⇓ (𝓋₁ ∸ 𝓋₂)

  𝕖-mul : ∀ {ℯ₂ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋₁ 𝓋₂ : 𝕍𝕒𝕝𝕦}
                            → ℱ ⊢ ℯ₂ ⇓ 𝓋₂
                            ---------------------------
                            → ℱ ⊢ (𝓋₁ *𝕖 ℯ₂) ⇓ (𝓋₁ * 𝓋₂)


postulate
  thm-𝕖 :  ∀ {ℯ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} → ℱ ⊢ ℯ ⇓ (⟦ ℯ ⟧𝕖 ℱ)


--
-- SEMANTICS of conditions as a decidable relation
--

data _⊢_ : 𝔽𝕣𝕞𝕖 → ℂ𝕠𝕟𝕕 → Set
data _⊬_ : 𝔽𝕣𝕞𝕖 → ℂ𝕠𝕟𝕕 → Set

data _⊢_ where

  𝕔-tt :  ∀ {ℱ : 𝔽𝕣𝕞𝕖}
          -----------
          → ℱ ⊢ ⇓true

  𝕔-and : ∀ {𝒸₁ 𝒸₂ : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
          → ℱ ⊢ 𝒸₁
          → ℱ ⊢ 𝒸₂
          ---------------
          → ℱ ⊢ (𝒸₁ ∧𝕔 𝒸₂)

  𝕔-or₁ : ∀ {𝒸₁ 𝒸₂ : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
          → ℱ ⊢ 𝒸₁
          ---------------
          → ℱ ⊢ (𝒸₁ ∨𝕔 𝒸₂)

  𝕔-or₂ : ∀ {𝒸₁ 𝒸₂ : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
          → ℱ ⊢ 𝒸₂
          ---------------
          → ℱ ⊢ (𝒸₁ ∨𝕔 𝒸₂)

  𝕔-less : ∀ {ℯ₁ ℯ₂ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋₁ 𝓋₂ : 𝕍𝕒𝕝𝕦}
           → 𝓋₁ < 𝓋₂ ≡ tt
           → ℱ ⊢ ℯ₁ ⇓ 𝓋₁
           → ℱ ⊢ ℯ₂ ⇓ 𝓋₂
           ----------------
           → ℱ ⊢ (ℯ₁ <𝕔 ℯ₂)

  𝕔-eq : ∀ {ℯ₁ ℯ₂ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋 : 𝕍𝕒𝕝𝕦}
           → ℱ ⊢ ℯ₁ ⇓ 𝓋
           → ℱ ⊢ ℯ₂ ⇓ 𝓋
           ----------------
           → ℱ ⊢ (ℯ₁ =𝕔 ℯ₂)

  𝕔-not : ∀ {𝒸 : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
          → ℱ ⊬ 𝒸
          ----------------
          → ℱ ⊢ (¬𝕔 𝒸)


data _⊬_ where

  ~𝕔-ff :  ∀ {ℱ : 𝔽𝕣𝕞𝕖}
           ------------
           → ℱ ⊬ ⇓false

  ~𝕔-or : ∀ {𝒸₁ 𝒸₂ : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
          → ℱ ⊬ 𝒸₁
          → ℱ ⊬ 𝒸₂
          -------------
          → ℱ ⊬ (𝒸₁ ∨𝕔 𝒸₂)

  ~𝕔-and₁ : ∀ {𝒸₁ 𝒸₂ : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
            → ℱ ⊬ 𝒸₁
            -------------
            → ℱ ⊬ (𝒸₁ ∧𝕔 𝒸₂)

  ~𝕔-and₂ : ∀ {𝒸₁ 𝒸₂ : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
            → ℱ ⊬ 𝒸₂
            -------------
            → ℱ ⊬ (𝒸₁ ∧𝕔 𝒸₂)

  ~𝕔-eq : ∀ {ℯ₁ ℯ₂ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋₁ 𝓋₂ : 𝕍𝕒𝕝𝕦}
            → 𝓋₁ =ℕ 𝓋₂ ≡ ff
            → ℱ ⊢ ℯ₁ ⇓ 𝓋₁
            → ℱ ⊢ ℯ₂ ⇓ 𝓋₂
            ----------------
            → ℱ ⊬ (ℯ₁ =𝕔 ℯ₂)

  ~𝕔-less : ∀ {ℯ₁ ℯ₂ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖} {𝓋₁ 𝓋₂ : 𝕍𝕒𝕝𝕦}
            → 𝓋₁ < 𝓋₂ ≡ ff
            → ℱ ⊢ ℯ₁ ⇓ 𝓋₁
            → ℱ ⊢ ℯ₂ ⇓ 𝓋₂
            ----------------
            → ℱ ⊬ (ℯ₁ <𝕔 ℯ₂)

  ~𝕔-not : ∀ {𝒸 : ℂ𝕠𝕟𝕕} {ℱ : 𝔽𝕣𝕞𝕖}
           → ℱ ⊢ 𝒸
           ----------------
           → ℱ ⊬ (¬𝕔 𝒸)

test3 : [] ⊢ (⇓true ∧𝕔 (¬𝕔 ⇓false))
test3 = 𝕔-and 𝕔-tt (𝕔-not ~𝕔-ff)

postulate
  thm-𝕔→ :  ∀ {𝒸 : ℂ𝕠𝕟𝕕}  {ℱ : 𝔽𝕣𝕞𝕖} → ℱ ⊢ 𝒸 → (⟦ 𝒸 ⟧𝕔 ℱ ≡ tt)
  thm-~𝕔→ :  ∀ {𝒸 : ℂ𝕠𝕟𝕕}  {ℱ : 𝔽𝕣𝕞𝕖} → ℱ ⊬ 𝒸 → (⟦ 𝒸 ⟧𝕔 ℱ ≡ ff)


--
-- SEMANTICS of program statements as a state transformation relation
--

data _=[_]⇒_ : 𝔽𝕣𝕞𝕖 → 𝕊𝕥𝕞𝕥 → 𝔽𝕣𝕞𝕖 → Set where

 𝕤-skip : ∀ {ℱ : 𝔽𝕣𝕞𝕖}
          --------------
          → ℱ =[ skip ]⇒ ℱ

 𝕤-assign : ∀ {𝒙 : 𝕀𝕕𝕖𝕟} {ℯ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖}  {𝓋 : 𝕍𝕒𝕝𝕦}
            → ℱ ⊢ ℯ ⇓ 𝓋
            ------------------------------
            → ℱ =[ 𝒙 ∷= ℯ ]⇒ (ℱ ∣ 𝒙 ↦ 𝓋)

 𝕤-seq : ∀ {𝓈₁ 𝓈₂ : 𝕊𝕥𝕞𝕥} {ℱ₀ ℱ₁ ℱ₂ : 𝔽𝕣𝕞𝕖}
         → ℱ₀ =[ 𝓈₁ ]⇒ ℱ₁
         → ℱ₁ =[ 𝓈₂ ]⇒ ℱ₂
         -------------------
         → ℱ₀ =[ 𝓈₁ ↩ 𝓈₂ ]⇒ ℱ₂

 𝕤-if-then : ∀ {𝒸 : ℂ𝕠𝕟𝕕} {𝓈₁ 𝓈₂ : 𝕊𝕥𝕞𝕥} {ℱ ℱ' : 𝔽𝕣𝕞𝕖}
             → ℱ ⊢ 𝒸
             → ℱ =[ 𝓈₁ ]⇒ ℱ'
             → ℱ =[ 𝓈₂ ]⇒ ℱ'
             -------------------
             → ℱ =[ if 𝒸 then 𝓈₁ else 𝓈₂ end ]⇒ ℱ'

 𝕤-if-else : ∀ {𝒸 : ℂ𝕠𝕟𝕕} {𝓈₁ 𝓈₂ : 𝕊𝕥𝕞𝕥} {ℱ ℱ' : 𝔽𝕣𝕞𝕖}
             → ℱ ⊬ 𝒸
             → ℱ =[ 𝓈₂ ]⇒ ℱ'
             -------------------
             → ℱ =[ if 𝒸 then 𝓈₁ else 𝓈₂ end ]⇒ ℱ'

 𝕤-repeat-0 : ∀ {𝓈 : 𝕊𝕥𝕞𝕥} {𝒙 : 𝕀𝕕𝕖𝕟} {ℱ : 𝔽𝕣𝕞𝕖}
             → ℱ ⊢ (⇑ 𝒙) ⇓ 0
             -------------------------
             → ℱ =[ by 𝒙 repeat 𝓈 end ]⇒ ℱ

 𝕤-repeat-suc : ∀ {n : ℕ} {𝓈 : 𝕊𝕥𝕞𝕥} {𝒙 : 𝕀𝕕𝕖𝕟} {ℱ ℱ' : 𝔽𝕣𝕞𝕖}
                → ℱ ⊢ (⇑ 𝒙) ⇓ suc n
                → ℱ =[ 𝓈 ↩ 𝒙 ∷= (⇓ n) ↩ by 𝒙 repeat 𝓈 end ]⇒ ℱ'
                -------------------------------------------
                → ℱ =[ by 𝒙 repeat 𝓈 end ]⇒ ℱ'

 -- I've cheated and treated "return" as an assignment, no jump out

 𝕤-return : ∀ {ℯ : 𝔼𝕩𝕡𝕟} {ℱ : 𝔽𝕣𝕞𝕖}  {𝓋 : 𝕍𝕒𝕝𝕦}
            → ℱ ⊢ ℯ ⇓ 𝓋
            ------------------------------
            → ℱ =[ returns ℯ ]⇒ (ℱ ∣ "retval" ↦ 𝓋)

[➊↦_] : 𝕍𝕒𝕝𝕦 → 𝔽𝕣𝕞𝕖
[➊↦ 𝓋 ] = [-↦0] ∣ arg1 ↦ 𝓋

[➊↦_,➋↦_] : 𝕍𝕒𝕝𝕦 →  𝕍𝕒𝕝𝕦 → 𝔽𝕣𝕞𝕖
[➊↦ 𝓋₁ ,➋↦ 𝓋₂ ] = (([-↦0] ∣ arg1 ↦ 𝓋₁) ∣ arg2 ↦ 𝓋₂ )

frame6 = (((((([-↦0] ∣ arg1 ↦ 3) ∣ X ↦ 0) ∣ Y ↦ 6) ∣ W ↦ 0) ∣ Z ↦ 6) ∣ retval ↦ 6)
postulate
  test6 : [➊↦ 3 ] =[ fact-pgm ]⇒ frame6


postulate
  thm-𝕤 : ∀ {𝓈 : 𝕊𝕥𝕞𝕥 } {ℱ : 𝔽𝕣𝕞𝕖} → ℱ =[ 𝓈 ]⇒ (⟦ 𝓈 ⟧𝕤 ℱ)

postulate
  thm-! : ∀ {n : ℕ} {ℱ : 𝔽𝕣𝕞𝕖} → [➊↦ n ] =[ fact-pgm ]⇒ ℱ → ℱ ⊢ retval ↦ (factorial n)
